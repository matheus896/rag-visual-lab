"""
Componentes de UI Reutiliz√°veis
================================

Este m√≥dulo cont√©m fun√ß√µes para renderizar elementos de UI consistentes
em todas as p√°ginas do Laborat√≥rio Visual de RAG.

Princ√≠pios:
- Componentes funcionais puros (sem efeitos colaterais)
- Nomenclatura clara e descritiva
- Encapsulamento de complexidade
- Consist√™ncia visual em todo o aplicativo
"""

import streamlit as st
from typing import Optional, List, Dict, Any


def render_document_uploader(
    accepted_types: List[str] = ["pdf", "txt", "md"],
    help_text: Optional[str] = None,
    key: Optional[str] = None
) -> Optional[Any]:
    """
    Renderiza um uploader de documentos com configura√ß√µes padr√£o.
    
    Args:
        accepted_types: Lista de extens√µes de arquivo aceitas
        help_text: Texto de ajuda opcional
        key: Chave √∫nica para o widget
        
    Returns:
        Arquivo carregado ou None
    """
    default_help = f"Tipos aceitos: {', '.join(accepted_types).upper()}"
    
    uploaded_file = st.file_uploader(
        "üìÑ Carregar Documento",
        type=accepted_types,
        help=help_text or default_help,
        key=key
    )
    
    return uploaded_file


def display_source_chunks(
    chunks: List[Dict[str, Any]],
    max_display: int = 5
) -> None:
    """
    Exibe os chunks de texto recuperados de forma organizada.
    
    Args:
        chunks: Lista de dicion√°rios com informa√ß√µes dos chunks
        max_display: N√∫mero m√°ximo de chunks a exibir
    """
    st.markdown("### üìö Chunks Recuperados")
    
    for i, chunk in enumerate(chunks[:max_display], 1):
        with st.expander(f"Chunk {i} - Score: {chunk.get('score', 'N/A')}"):
            st.markdown(f"**Conte√∫do:**")
            st.text(chunk.get('content', ''))
            
            if 'metadata' in chunk:
                st.markdown("**Metadados:**")
                st.json(chunk['metadata'])


def render_parameter_controls(
    default_chunk_size: int = 1200,
    default_overlap: int = 100,
    default_top_k: int = 5
) -> Dict[str, int]:
    """
    Renderiza controles de par√¢metros para o RAG.
    
    Args:
        default_chunk_size: Tamanho padr√£o do chunk
        default_overlap: Overlap padr√£o entre chunks
        default_top_k: N√∫mero padr√£o de resultados
        
    Returns:
        Dicion√°rio com os valores dos par√¢metros
    """
    st.sidebar.markdown("### ‚öôÔ∏è Par√¢metros")
    
    chunk_size = st.sidebar.slider(
        "Tamanho do Chunk",
        min_value=100,
        max_value=2000,
        value=default_chunk_size,
        step=100,
        help="N√∫mero de tokens por chunk de texto"
    )
    
    overlap = st.sidebar.slider(
        "Overlap entre Chunks",
        min_value=0,
        max_value=500,
        value=default_overlap,
        step=50,
        help="Tokens compartilhados entre chunks consecutivos"
    )
    
    top_k = st.sidebar.slider(
        "Top K Resultados",
        min_value=1,
        max_value=20,
        value=default_top_k,
        help="N√∫mero de chunks mais relevantes a recuperar"
    )
    
    return {
        "chunk_size": chunk_size,
        "overlap": overlap,
        "top_k": top_k
    }


def display_metrics_cards(metrics: Dict[str, Any]) -> None:
    """
    Exibe m√©tricas em cards formatados.
    
    Args:
        metrics: Dicion√°rio com as m√©tricas a exibir
    """
    cols = st.columns(len(metrics))
    
    for col, (label, value) in zip(cols, metrics.items()):
        with col:
            st.metric(label=label, value=value)


def render_loading_message(message: str = "Processando...") -> None:
    """
    Exibe uma mensagem de carregamento padronizada.
    
    Args:
        message: Mensagem a exibir
    """
    with st.spinner(message):
        st.empty()


def display_info_box(
    title: str,
    content: str,
    box_type: str = "info"
) -> None:
    """
    Exibe uma caixa de informa√ß√£o formatada.
    
    Args:
        title: T√≠tulo da caixa
        content: Conte√∫do da caixa
        box_type: Tipo da caixa (info, success, warning, error)
    """
    box_functions = {
        "info": st.info,
        "success": st.success,
        "warning": st.warning,
        "error": st.error
    }
    
    box_func = box_functions.get(box_type, st.info)
    box_func(f"**{title}**\n\n{content}")


def display_embedding_visualization_guide(embedding_dim: int) -> None:
    """
    Exibe um guia educacional sobre visualiza√ß√£o de embeddings.
    
    Args:
        embedding_dim: Dimens√£o original dos embeddings
    """
    with st.expander("üß≠ Como Ler o Gr√°fico de Embeddings?", expanded=False):
        st.markdown(f"""
        ### üìö Analogia da Biblioteca
        
        Imagine que cada chunk do seu documento √© um **livro em uma biblioteca gigante**.
        
        **Problema:** Sua "biblioteca" tem **{embedding_dim} estantes** (dimens√µes)!  
        √â imposs√≠vel visualizar {embedding_dim} dimens√µes de uma vez.
        
        **Solu√ß√£o:** Usamos uma t√©cnica chamada **PCA** (an√°lise de componentes principais)
        que √© como tirar uma **foto 3D** dessa biblioteca enorme.
        
        ---
        
        ### üéØ O Que Cada Elemento Significa?
        
        - **üîµ Cada ponto azul** = 1 chunk do seu documento
        - **Proximidade** = Chunks similares ficam pr√≥ximos
        - **Dist√¢ncia** = Chunks diferentes ficam afastados
        - **Agrupamentos** = T√≥picos ou temas semelhantes
        
        ---
        
        ### üñ±Ô∏è Interatividade
        
        - **Passe o mouse** sobre um ponto para ver o conte√∫do do chunk
        - **Clique e arraste** para rotacionar o gr√°fico 3D
        - **Scroll** para dar zoom
        - **Duplo clique** para resetar a visualiza√ß√£o
        """)


def display_pca_explainer() -> None:
    """
    Explica o conceito de PCA (Principal Component Analysis) em linguagem simples.
    """
    with st.expander("üî¨ O Que √© PCA? (Explica√ß√£o Simples)", expanded=False):
        st.markdown("""
        ### üé¨ Imagine Descrever Uma Pessoa
        
        Voc√™ poderia usar **centenas de caracter√≠sticas**:
        - Altura, peso, cor dos olhos, tamanho do p√©, cor do cabelo...
        - Comprimento dos dedos, largura dos ombros, tom de voz...
        
        Mas se voc√™ precisasse resumir em **apenas 3 caracter√≠sticas principais**, 
        quais escolheria? Provavelmente:
        1. **Altura** (mais importante)
        2. **Peso** (segunda mais importante)
        3. **Idade** (terceira mais importante)
        
        ---
        
        ### üßÆ √â Isso Que PCA Faz!
        
        **PCA** pega suas **768 dimens√µes** e encontra as **3 dire√ß√µes** que capturam
        **o m√°ximo de informa√ß√£o poss√≠vel**.
        
        Pense assim:
        ```
        768 dimens√µes  ‚Üí  [PCA m√°gico]  ‚Üí  3 dimens√µes principais
        (imposs√≠vel ver)                    (voc√™ consegue ver!)
        ```
        
        ---
        
        ### ‚úÖ Por Que Isso √© √ötil?
        
        - ‚ú® **Visualizar** padr√µes que existem em alta dimens√£o
        - üîç **Encontrar** agrupamentos de chunks similares
        - üìä **Entender** como seus documentos est√£o organizados
        - üéØ **Debugar** problemas no chunking ou embeddings
        
        ---
        
        ### ‚ö†Ô∏è Limita√ß√£o Importante
        
        Ao reduzir de 768 ‚Üí 3 dimens√µes, **perdemos detalhes**.  
        √â como tirar uma foto 2D de um objeto 3D: captura a ess√™ncia, mas n√£o tudo.
        """)


def display_variance_explainer(
    variance_explained: List[float],
    total_variance: float
) -> None:
    """
    Explica o conceito de vari√¢ncia explicada de forma did√°tica.
    
    Args:
        variance_explained: Lista com vari√¢ncia de cada componente
        total_variance: Vari√¢ncia total explicada
    """
    with st.expander("üìä O Que Significam Esses Percentuais?", expanded=False):
        st.markdown(f"""
        ### üéØ Vari√¢ncia Explicada = "Quanta informa√ß√£o mantivemos?"
        
        Quando reduzimos **768 dimens√µes ‚Üí 3 dimens√µes**, inevitavelmente **perdemos informa√ß√£o**.
        
        A **vari√¢ncia explicada** nos diz: *"Qu√£o fiel √© essa visualiza√ß√£o 3D comparada aos dados originais?"*
        
        ---
        
        ### üìà Seus N√∫meros:
        
        - **PC1 (Componente Principal 1):** {variance_explained[0]:.1%}
          - A dire√ß√£o mais importante! Captura {variance_explained[0]:.1%} da varia√ß√£o total
        
        - **PC2 (Componente Principal 2):** {variance_explained[1]:.1%}
          - Segunda dire√ß√£o mais importante
        
        - **PC3 (Componente Principal 3):** {variance_explained[2]:.1%}
          - Terceira dire√ß√£o mais importante
        
        - **üìä TOTAL:** {total_variance:.1%}
          - Capturamos {total_variance:.1%} da informa√ß√£o original!
        
        ---
        
        ### ü§î {total_variance:.1%} √© Bom ou Ruim?
        
        """)
        
        # Barra de progresso visual
        st.progress(total_variance)
        
        # Interpreta√ß√£o baseada no valor
        if total_variance >= 0.7:
            st.success(f"""
            ‚úÖ **Excelente!** {total_variance:.1%} √© muito bom!  
            Sua visualiza√ß√£o 3D captura a maior parte da estrutura dos dados.
            """)
        elif total_variance >= 0.4:
            st.info(f"""
            ‚úîÔ∏è **Bom!** {total_variance:.1%} √© adequado para visualiza√ß√£o.  
            Voc√™ est√° vendo os padr√µes principais, embora alguns detalhes sejam perdidos.
            """)
        elif total_variance >= 0.2:
            st.warning(f"""
            ‚ö†Ô∏è **Razo√°vel.** {total_variance:.1%} significa que muita informa√ß√£o foi comprimida.  
            A visualiza√ß√£o mostra tend√™ncias gerais, mas perde bastante detalhe.
            """)
        else:
            st.warning(f"""
            ‚ö†Ô∏è **Limitado.** {total_variance:.1%} √© baixo.  
            A visualiza√ß√£o 3D √© muito simplificada. Os dados originais s√£o muito complexos.
            """)
        
        st.markdown("""
        ---
        
        ### üí° Dica Pr√°tica
        
        **Para embeddings de texto**, valores entre **20-40%** s√£o normais!  
        Embeddings s√£o **intencionalmente de alta dimens√£o** para capturar nuances
        da linguagem, ent√£o √© **imposs√≠vel** capturar tudo em 3D.
        
        O importante √© que voc√™ consiga **ver padr√µes** de agrupamento no gr√°fico! üéØ
        """)
